<!doctype html>

<!--
Hill Climb Racing — Rizwan Edition
Single-file HTML/JS game (canvas). Professional-feel lightweight clone inspired by Hill Climb Racing.
Features:
- Procedural hilly terrain
- Simple vehicle physics (body + two wheels + suspension-ish behavior)
- Score (distance), fuel, speed
- Vehicle color chooser (color input + presets)
- "RIZWAN" text painted on vehicle body
- Keyboard controls (ArrowLeft/ArrowRight or A/D), touch buttons for mobile
- Responsive canvas and simple UI

Usage:
1) Save this file as `index.html` and open it in a modern browser (Chrome/Edge/Firefox) on desktop or mobile.
2) For hosting: upload to GitHub Pages, Netlify, Vercel etc.

Customize:
- Change vehicle parameters in the `vehicleConfig` object below.
- Change terrain generation seeds/parameters in `generateTerrain`.

Author: Generated by ChatGPT — Rizwan Edition
--><html lang="ur">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Hill Climb — Rizwan Edition</title>
  <style>
    :root{--bg:#0b1020;--panel:#0f1724;--text:#e6eef8;--muted:#9fb0c8}
    html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Arial;direction:rtl}
    body{background:linear-gradient(180deg,#051028 0%, #08152a 60%, #0b1020 100%);color:var(--text);
      display:flex;align-items:center;justify-content:center;padding:12px}
    .wrap{width:min(980px,100%);max-width:1000px}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    h1{font-size:18px;margin:0}
    .controls{display:flex;gap:10px;align-items:center}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:10px;border-radius:10px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    canvas{width:100%;height:560px;border-radius:12px;display:block}
    .hud{display:flex;gap:10px;align-items:center}
    .stat{font-size:14px;color:var(--muted)}
    .btn{background:#0f1724;border:1px solid rgba(255,255,255,0.04);padding:6px 10px;border-radius:8px;color:var(--text);cursor:pointer}
    .small{font-size:13px}
    .color-row{display:flex;align-items:center;gap:8px}
    input[type="color"]{width:42px;height:34px;border-radius:8px;border:0;padding:0}
    .touch-controls{display:flex;gap:8px}
    .touch-button{width:84px;height:44px;border-radius:10px;background:rgba(255,255,255,0.04);display:flex;align-items:center;justify-content:center;font-weight:600}
    @media (max-width:640px){canvas{height:520px}.touch-button{width:46%;}}
    .footer{margin-top:8px;font-size:13px;color:var(--muted);display:flex;justify-content:space-between}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Hill Climb — <strong>Rizwan Edition</strong></h1>
      <div class="controls">
        <div class="panel hud">
          <div class="stat">سکور: <span id="score">0</span></div>
          <div class="stat">رفتار: <span id="speed">0</span> km/h</div>
          <div class="stat">فیول: <span id="fuel">100</span>%</div>
        </div>
        <button id="restart" class="btn">ریسٹارٹ</button>
      </div>
    </header><div class="panel">
  <canvas id="gameCanvas" width="960" height="540"></canvas>

  <div style="display:flex;justify-content:space-between;align-items:center;margin-top:10px">
    <div style="display:flex;gap:12px;align-items:center">
      <div class="color-row">
        رنگ تبدیل کریں:
        <input id="colorPicker" type="color" value="#ff3b3b">
        <button data-color="#ff3b3b" class="btn small preset">سرخ</button>
        <button data-color="#00d1ff" class="btn small preset">نیلا</button>
        <button data-color="#3bff7a" class="btn small preset">سبز</button>
      </div>
    </div>
    <div style="display:flex;gap:8px;align-items:center">
      <div class="small">کنٹرول: ← → یا A / D</div>
    </div>
  </div>

  <div style="margin-top:10px;display:flex;gap:8px;align-items:center;justify-content:center" class="touch-controls">
    <div id="touchLeft" class="touch-button">بریک/پچھے</div>
    <div id="touchRight" class="touch-button">گیس/آگے</div>
  </div>

</div>

<div class="footer">
  <div>اس گیم میں گاڑیوں پر <strong>RIZWAN</strong> لکھا جاتا ہے۔</div>
  <div>Developed by ChatGPT • Save as <code>index.html</code></div>
</div>

  </div><script>
// Hill Climb Racing — Rizwan Edition
// Basic yet polished single-file game. Physics is simplified for smooth mobile experience.

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;

// UI elements
const scoreEl = document.getElementById('score');
const speedEl = document.getElementById('speed');
const fuelEl = document.getElementById('fuel');
const restartBtn = document.getElementById('restart');
const colorPicker = document.getElementById('colorPicker');
const presetBtns = document.querySelectorAll('.preset');
const touchLeft = document.getElementById('touchLeft');
const touchRight = document.getElementById('touchRight');

// Game state
let keys = {left:false,right:false};
let touch = {left:false,right:false};
let cameraX = 0;
let distance = 0;
let speed = 0; // px/s
let fuel = 100;
let running = true;
let timeLast = performance.now();

// CONFIG
const terrainConfig = {segmentLength: 40, amplitude: 110, wavelength: 600, roughness: 0.9};
const vehicleConfig = {
  bodyWidth: 120, bodyHeight: 34,
  wheelRadius: 20,
  wheelBase: 72, // distance between wheels centers
  maxEngineForce: 220, // acceleration force
  maxBrakeForce: 300,
  mass: 18, // influences inertia
  suspension: 0.15,
  color:'#ff3b3b'
};

// VEHICLE PHYSICS (simplified)
const vehicle = {
  x: 150, // world position (px)
  y: 0,
  angle: 0,
  vx: 0, vy: 0,
  ax: 0, ay: 0,
  wheelOffsetFront: vehicleConfig.wheelBase/2,
  wheelOffsetBack: -vehicleConfig.wheelBase/2,
  wheelFL: {x:0,y:0,ang:0,vs:0},
  wheelFR: {x:0,y:0,ang:0,vs:0}
};

// Terrain data
let terrain = []; // array of {x, y}
const seed = Math.random()*1000;

function noise(x){
  // simple pseudo-noise using sin + tiny randomness
  return Math.sin((x+seed)/terrainConfig.wavelength*Math.PI*2) * terrainConfig.amplitude + (Math.sin((x*0.03+seed))*30);
}

function generateTerrain(startX, endX){
  terrain = [];
  for(let x = startX; x <= endX; x += terrainConfig.segmentLength){
    let y = H*0.62 - noise(x);
    // add some randomness to make hills more natural
    y += (Math.sin((x+seed)*0.005) * 40);
    terrain.push({x: x, y: y});
  }
}

function getTerrainY(x){
  // linear interpolate between nearest points
  if(x <= terrain[0].x) return terrain[0].y;
  for(let i=0;i<terrain.length-1;i++){
    const a = terrain[i], b = terrain[i+1];
    if(x >= a.x && x <= b.x){
      const t = (x - a.x)/(b.x - a.x);
      return a.y*(1-t) + b.y*t;
    }
  }
  return terrain[terrain.length-1].y;
}

// Controls
window.addEventListener('keydown', e=>{
  if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A'){ keys.left=true; }
  if(e.key==='ArrowRight' || e.key==='d' || e.key==='D'){ keys.right=true; }
});
window.addEventListener('keyup', e=>{
  if(e.key==='ArrowLeft' || e.key==='a' || e.key==='A'){ keys.left=false; }
  if(e.key==='ArrowRight' || e.key==='d' || e.key==='D'){ keys.right=false; }
});

// Touch controls
touchLeft.addEventListener('touchstart', e=>{ e.preventDefault(); touch.left=true; });
touchLeft.addEventListener('touchend', e=>{ touch.left=false; });

touchRight.addEventListener('touchstart', e=>{ e.preventDefault(); touch.right=true; });
touchRight.addEventListener('touchend', e=>{ touch.right=false; });

// Color controls
colorPicker.addEventListener('input', e=>{ vehicleConfig.color = e.target.value; });
presetBtns.forEach(b=> b.addEventListener('click', ()=>{ vehicleConfig.color = b.dataset.color; colorPicker.value = b.dataset.color; }));

restartBtn.addEventListener('click', ()=>{ init(); });

function init(){
  // set initial vehicle
  vehicle.x = 150; vehicle.vx = 0; vehicle.vy = 0; vehicle.angle = 0;
  distance = 0; speed = 0; fuel = 100; running = true;
  generateTerrain(-2000, 20000);
  cameraX = 0;
  timeLast = performance.now();
}

function physicsStep(dt){
  // dt in seconds
  // engine/brake input
  const accelInput = (keys.right || touch.right) ? 1 : 0;
  const brakeInput = (keys.left || touch.left) ? 1 : 0;

  // engine force
  const engineForce = accelInput * vehicleConfig.maxEngineForce;
  const brakeForce = brakeInput * vehicleConfig.maxBrakeForce;

  // approximate slope influence by sampling terrain under wheels
  const frontX = vehicle.x + vehicle.wheelOffsetFront;
  const backX = vehicle.x + vehicle.wheelOffsetBack;
  const yFront = getTerrainY(frontX);
  const yBack = getTerrainY(backX);
  const slope = Math.atan2(yFront - yBack, frontX - backX);

  // apply forces
  const gravity = 9.8 * vehicleConfig.mass;
  // simplified: acceleration = (engine - rolling - gravity component)/mass
  const rollingResistance = 0.8 * Math.sign(vehicle.vx) ;

  const forceX = engineForce - brakeForce - rollingResistance - Math.sin(slope) * gravity * 0.6;
  const ax = forceX / vehicleConfig.mass;

  // integrate
  vehicle.vx += ax * dt;
  // clamp
  vehicle.vx = Math.max(-40, Math.min(180, vehicle.vx));

  // simple collision with terrain at body center
  const bodyYTarget = getTerrainY(vehicle.x) - (vehicleConfig.bodyHeight/2 + vehicleConfig.wheelRadius + 2);
  vehicle.vy += 200 * dt; // gravity-ish
  vehicle.y += vehicle.vy * dt;

  // when below target, push up
  if(vehicle.y > bodyYTarget){
    vehicle.y = bodyYTarget;
    vehicle.vy = 0;
    // some bounce
  }

  // wheels rotation speed from vx
  const wheelCirc = Math.PI * 2 * vehicleConfig.wheelRadius;
  vehicle.wheelFL.vs = vehicle.vx / wheelCirc;
  vehicle.wheelFR.vs = vehicle.vx / wheelCirc;

  // angle approximates slope
  vehicle.angle = slope * 0.7;

  // update distance & fuel
  const travelled = vehicle.vx * dt;
  if(travelled > 0) distance += travelled;
  fuel -= Math.abs(engineForce) * 0.00008 * dt;
  fuel = Math.max(0, fuel);
  if(fuel <= 0) { vehicle.vx *= 0.995; }

  speed = vehicle.vx * 0.36; // px/s -> km/h approx
}

function update(dt){
  if(!running) return;
  physicsStep(dt);
  // move camera to follow vehicle
  cameraX = Math.max(0, vehicle.x - W*0.36);
}

function drawGround(){
  // draw big terrain path
  ctx.beginPath();
  const start = Math.floor((cameraX-300)/terrainConfig.segmentLength);
  const end = Math.ceil((cameraX + W + 300)/terrainConfig.segmentLength);
  // build path
  for(let i = Math.max(0,start); i < Math.min(terrain.length,end); i++){
    const p = terrain[i];
    const sx = (p.x - cameraX);
    const sy = p.y;
    if(i===Math.max(0,start)) ctx.moveTo(sx, sy);
    else ctx.lineTo(sx, sy);
  }
  // bottom corners
  ctx.lineTo(W, H+200);
  ctx.lineTo(0, H+200);
  ctx.closePath();
  // gradient
  const g = ctx.createLinearGradient(0,0,0,H);
  g.addColorStop(0,'#27404a'); g.addColorStop(1,'#1b2b2f');
  ctx.fillStyle = g;
  ctx.fill();

  // road line
  ctx.beginPath();
  for(let i = Math.max(0,start); i < Math.min(terrain.length,end); i++){
    const p = terrain[i];
    const sx = (p.x - cameraX);
    const sy = p.y + 6;
    if(i===Math.max(0,start)) ctx.moveTo(sx, sy);
    else ctx.lineTo(sx, sy);
  }
  ctx.lineWidth = 4; ctx.strokeStyle = '#2e8b57'; ctx.stroke();
}

function drawVehicle(){
  const cx = vehicle.x - cameraX;
  const cy = vehicle.y;

  // body
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(vehicle.angle);

  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.fillRect(-vehicleConfig.bodyWidth/2 + 6, vehicleConfig.bodyHeight/2 + 10, vehicleConfig.bodyWidth - 4, 10);

  // body rect
  ctx.fillStyle = vehicleConfig.color;
  roundRect(ctx, -vehicleConfig.bodyWidth/2, -vehicleConfig.bodyHeight/2, vehicleConfig.bodyWidth, vehicleConfig.bodyHeight, 10, true, false);

  // windows
  ctx.fillStyle = 'rgba(0,0,0,0.18)';
  ctx.fillRect(-22, -vehicleConfig.bodyHeight/2 + 6, 44, 16);

  // RIZWAN text centered on body
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 16px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('RIZWAN', 0, 6);

  ctx.restore();

  // wheels (drawn relative to ground under vehicle body)
  const wheelFLx = vehicle.x + vehicle.wheelOffsetBack - cameraX;
  const wheelFRx = vehicle.x + vehicle.wheelOffsetFront - cameraX;
  const wheelY = getTerrainY(vehicle.x) - vehicleConfig.wheelRadius;

  // back wheel
  drawWheel(wheelFLx, wheelY, vehicleConfig.wheelRadius, vehicle.wheelFL.vs);
  // front wheel
  drawWheel(wheelFRx, wheelY, vehicleConfig.wheelRadius, vehicle.wheelFR.vs);
}

function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (typeof stroke === 'undefined') stroke = true;
  if (typeof r === 'undefined') r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.strokeStyle = 'rgba(0,0,0,0.08)'; ctx.stroke();
}

function drawWheel(x,y,r,rotSpeed){
  // simple wheel with rotation animation
  ctx.save();
  ctx.translate(x, y);
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fillStyle = '#111'; ctx.fill();
  ctx.lineWidth = 4; ctx.strokeStyle = '#222'; ctx.stroke();
  // spokes
  ctx.rotate((performance.now()*0.002*rotSpeed)%Math.PI);
  ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth = 2;
  for(let i=0;i<6;i++){
    ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.cos(i*Math.PI/3)*(r-6), Math.sin(i*Math.PI/3)*(r-6)); ctx.stroke();
  }
  ctx.restore();
}

function render(){
  // clear
  ctx.clearRect(0,0,W,H);

  // sky gradient
  const sky = ctx.createLinearGradient(0,0,0,H);
  sky.addColorStop(0,'#11253a'); sky.addColorStop(1,'#072033');
  ctx.fillStyle = sky; ctx.fillRect(0,0,W,H);

  // draw distant hills (parallax)
  ctx.save();
  ctx.translate(-cameraX*0.2, 0);
  drawParallaxHills();
  ctx.restore();

  drawGround();
  drawVehicle();

  // HUD drawn on top
}

function drawParallaxHills(){
  // soft hills behind main terrain
  ctx.beginPath();
  for(let x = -500; x < W + 500; x += 80){
    const sx = x + 200; const sy = H*0.65 + Math.sin((x+cameraX*0.08)*0.006)*60;
    if(x===-500) ctx.moveTo(sx,sy); else ctx.lineTo(sx,sy);
  }
  ctx.lineTo(W+500,H+200); ctx.lineTo(-500,H+200); ctx.closePath();
  ctx.fillStyle = 'rgba(32,56,60,0.45)'; ctx.fill();
}

function gameLoop(now){
  const dt = Math.min(0.05, (now - timeLast)/1000);
  timeLast = now;
  if(running){
    // combine keys & touches
    const prevX = vehicle.x;
    update(dt);
    // advance vehicle x by vx*dt
    vehicle.x += vehicle.vx * dt;
    // clamp into terrain bounds
    vehicle.x = Math.max(0, vehicle.x);

    // if vehicle falls too far (flips) reduce running or stop
    if(vehicle.y > H + 200) running = false;

    // if out of terrain regen more
    if(vehicle.x > terrain[terrain.length-10].x - 400){
      generateTerrain(terrain[0].x, terrain[terrain.length-1].x + 15000);
    }

    // update UI
    scoreEl.textContent = Math.floor(distance);
    speedEl.textContent = Math.max(0, Math.round(speed));
    fuelEl.textContent = Math.max(0, Math.round(fuel));
  }

  render();
  if(!running){
    // overlay game over
    ctx.fillStyle = 'rgba(0,0,0,0.45)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.font = '28px sans-serif'; ctx.textAlign = 'center';
    ctx.fillText('Game Over', W/2, H/2 - 10);
    ctx.font = '16px sans-serif'; ctx.fillText('Press Restart to try again', W/2, H/2 + 18);
  }

  requestAnimationFrame(gameLoop);
}

// responsive
function onResize(){
  const rect = canvas.getBoundingClientRect();
  // don't change internal rendering size (keeps physics consistent)
}
window.addEventListener('resize', onResize);

// start
init();
requestAnimationFrame(gameLoop);

</script></body>
</html>
